#ifndef QOIPP_SIMPLE_HPP_GO84ERGTVF6
#define QOIPP_SIMPLE_HPP_GO84ERGTVF6

#include "qoipp/common.hpp"

#include <filesystem>
#include <optional>
#include <version>

namespace qoipp
{
    struct EncodeStatus
    {
        std::size_t written;
        bool        complete;
    };

    /**
     * @brief Read the header of a QOI image.
     *
     * @param in_data The data to read the header from.
     * @return The description of QOI image if it is a valid QOI header.
     *
     * This function returns
     * - `Error::Empty` if the length of the data is zero,
     * - `Error::TooShort` if the length of the data passed in less than header length,
     * - `Error::NotQoi` if the the data does not describe a QOI header, or
     * - `Error::InvalidDesc` if any of the parsed field of `Desc` contains invalid value.
     */
    Result<Desc> read_header(ByteCSpan in_data) noexcept;

    /**
     * @brief Read the header of a QOI image from a file.
     *
     * @param in_path The path to the file.
     * @return The description of the image (std::nullopt if it's invalid).
     *
     * This function returns
     * - `Error::Empty` if the data read from file empty,
     * - `Error::TooShort` if the length of the data read from file less than header length,
     * - `Error::NotQoi` if the the data read from file does not describe a QOI header,
     * - `Error::InvalidDesc` if any of the parsed field of `Desc` contains invalid value,
     * - `Error::NotRegularFile` if file pointed by path is not a regular file,
     * - `Error::FileNotExists` if file pointed by path not exists, or
     * - `Error::IoError` if file can't be opened or read.
     */
    Result<Desc> read_header(const std::filesystem::path& in_path) noexcept;

    /**
     * @brief Encode the given data into a QOI image.
     *
     * @param in_data The data to encode.
     * @param desc The description of the image.
     * @return The encoded image or an error.
     *
     * This function assumes that the raw data is in the format of RGB888 or RGBA8888.
     *
     * This function returns
     * - `Error::Empty` if the length of the data is zero,
     * - `Error::TooBig` if the image is too big to process,
     * - `Error::InvalidDesc` if any of the field of `Desc` contains invalid value, or
     * - `Error::MismatchedDesc` if the number of pixel data doesn't match the image description.
     */
    Result<ByteVec> encode(ByteCSpan in_data, Desc desc) noexcept;

    /**
     * @brief Encode data generated by the given function into a QOI image.
     *
     * @param in_func The function to generate the data (noexcept).
     * @param desc The description of the image.
     * @return The encoded image or an error.
     *
     * The function should return the pixel at the given pixel index. The index 0 starts at top-left corner of
     * an image and increasing to the right and then down. The alpha channel value is discarded if the Desc
     * specifies RGB channels only.
     *
     * This function returns
     * - `Error::TooBig` if the image is too big to process,
     * - `Error::InvalidDesc` if any of the field of `Desc` contains invalid value.
     */
    Result<ByteVec> encode(PixelGenFun in_func, Desc desc) noexcept;

    /**
     * @brief Encode the given data into a QOI image.
     *
     * @param out_buf The buffer to be filled with encoded data.
     * @param in_data The data to encode.
     * @param desc The description of the image.
     * @return The status of encoding an error.
     *
     * This function assumes that the raw data is in the format of RGB888 or RGBA8888.
     *
     * Unlike `decode_into` functions, this function won't return `Error::NotEnoughSpace` if the `out_buf`
     * doesn't have enough space since it can't know the size of the encoded data beforehand. The encoder
     * will just encode the data until it hit the out buffer limit or the encoding complete.
     *
     * While this function will partially encode the data, it won't have partial/unfinished data chunk. What
     * that means is that even though the buffer might be not enough, it might still have zeroes not filled
     * at the end of the buffer. The encoder might simply cannot fit the encoded data into the buffer if the
     * chunk size is greater than the remaining space (for example QOI_OP_RGBA is a 5 bytes chunk, the
     * encoder won't write this data into the buffer if the buffer only have 4 bytes left).
     *
     * This function returns
     * - `Error::Empty` if the length of the data is zero,
     * - `Error::TooBig` if the image is too big to process,
     * - `Error::InvalidDesc` if any of the field of `Desc` contains invalid value, or
     * - `Error::MismatchedDesc` if the number of pixel data doesn't match the image description.
     */
    Result<EncodeStatus> encode_into(ByteSpan out_buf, ByteCSpan in_data, Desc desc);

    /**
     * @brief Encode data generated by the given function into a QOI image.
     *
     * @param out_buf The buffer to be filled with encoded data.
     * @param in_func The function to generate the data (noexcept).
     * @param desc The description of the image.
     * @return The status of encoding an error.
     *
     * Unlike `decode_into` functions, this function won't return `Error::NotEnoughSpace` if the `out_buf`
     * doesn't have enough space since it can't know the size of the encoded data beforehand. The encoder
     * will just encode the data until it hit the out buffer limit or the encoding complete.
     *
     * While this function will partially encode the data, it won't have partial/unfinished data chunk. What
     * that means is that even though the buffer might be not enough, it might still have zeroes not filled
     * at the end of the buffer. The encoder might simply cannot fit the encoded data into the buffer if the
     * chunk size is greater than the remaining space (for example QOI_OP_RGBA is a 5 bytes chunk, the
     * encoder won't write this data into the buffer if the buffer only have 4 bytes left).
     *
     * This function assumes that the raw data is in the format of RGB888 or RGBA8888.
     *
     * This function returns
     * - `Error::TooBig` if the image is too big to process, or
     * - `Error::InvalidDesc` if any of the field of `Desc` contains invalid value.
     */
    Result<EncodeStatus> encode_into(ByteSpan out_buf, PixelGenFun in_func, Desc desc);

    /**
     * @brief Encode the given data into a QOI image.
     *
     * @param out_func The function that accepts the encoded data (noexcept).
     * @param in_data The data to encode.
     * @param desc The description of the image.
     * @return The number of encoded data.
     *
     * This function assumes that the raw data is in the format of RGB888 or RGBA8888.
     *
     * This function returns
     * - `Error::Empty` if the length of the data is zero,
     * - `Error::TooBig` if the image is too big to process,
     * - `Error::InvalidDesc` if any of the field of `Desc` contains invalid value,
     * - `Error::MismatchedDesc` if the number of pixel data doesn't match the image description, or
     */
    Result<std::size_t> encode_into(ByteSinkFun out_func, ByteCSpan in_data, Desc desc);

    /**
     * @brief Encode data generated by the given function into a QOI image.
     *
     * @param out_func The function that accepts the encoded data (noexcept).
     * @param in_func The function to generate the data (noexcept).
     * @param desc The description of the image.
     * @return The number of encoded data.
     *
     * This function assumes that the raw data is in the format of RGB888 or RGBA8888.
     *
     * This function returns
     * - `Error::TooBig` if the image is too big to process,
     * - `Error::InvalidDesc` if any of the field of `Desc` contains invalid value, or
     */
    Result<std::size_t> encode_into(ByteSinkFun out_func, PixelGenFun in_func, Desc desc);

    /**
     * @brief Encode the given data into a QOI image and write it to a file.
     *
     * @param out_path The path to the file.
     * @param in_data The data to encode.
     * @param desc The description of the image.
     * @param overwrite If true, the file will be overwritten if it already exists.
     * @return The number of encoded data or an error.
     *
     * This function returns
     * - `Error::Empty` if the length of the data is zero,
     * - `Error::TooBig` if the image is too big to process,
     * - `Error::InvalidDesc` if any of the field of `Desc` contains invalid value,
     * - `Error::MismatchedDesc` if the number of pixel data doesn't match the image description,
     * - `Error::NotRegularFile` if overwrite is set to true and file is not a regular file,
     * - `Error::FileExists` if file pointed by path exists and overwrite is set to false, or
     * - `Error::IoError` if file can't be opened or written.
     */
    Result<std::size_t> encode_into(
        const std::filesystem::path& out_path,
        ByteCSpan                    in_data,
        Desc                         desc,
        bool                         overwrite = false
    ) noexcept;

    /**
     * @brief Encode the given data into a QOI image and write it to a file.
     *
     * @param out_path The path to the file.
     * @param in_func The function to generate the data (noexcept).
     * @param desc The description of the image.
     * @param overwrite If true, the file will be overwritten if it already exists.
     * @return The number of encoded data or an error.
     *
     * This function returns
     * - `Error::TooBig` if the image is too big to process,
     * - `Error::InvalidDesc` if any of the field of `Desc` contains invalid value,
     * - `Error::NotRegularFile` if overwrite is set to true and file is not a regular file, or
     * - `Error::FileExists` if file pointed by path exists and overwrite is set to false,
     * - `Error::IoError` if file can't be opened or written.
     */
    Result<std::size_t> encode_into(
        const std::filesystem::path& out_path,
        PixelGenFun                  in_func,
        Desc                         desc,
        bool                         overwrite = false
    ) noexcept;

    /**
     * @brief Decode the given QOI image.
     *
     * @param in_data The QOI image to decode.
     * @param target The target channels to extract; if std::nullopt, the original channels will be used.
     * @param flip_vertically If true, the image will be flip vertically.
     * @return The decoded image or an error.
     *
     * If the underlying data is RGB and the target is RGBA, the alpha channel will be set to 0xFF.
     *
     * This function returns
     * - `Error::Empty` if the length of the data is zero,
     * - `Error::TooShort` if the length of the data passed in less than header length,
     * - `Error::TooBig` if the image is too big to process,
     * - `Error::NotQoi` if the the data does not describe a QOI header, or
     * - `Error::InvalidDesc` if any of the field on the header contains invalid value.
     */
    Result<Image> decode(
        ByteCSpan               in_data,
        std::optional<Channels> target          = std::nullopt,
        bool                    flip_vertically = false
    ) noexcept;

    /**
     * @brief Decode a QOI image from a file.
     *
     * @param in_path The path to the file.
     * @param target The target channels to extract; if std::nullopt, the original channels will be used.
     * @return Image The decoded image or an error.
     *
     * If the underlying data is RGB and the target is RGBA, the alpha channel will be set to 0xFF.
     *
     * This function returns
     * - `Error::Empty` if the length of the data read from file is zero,
     * - `Error::TooShort` if the length of the data read from file in less than header length,
     * - `Error::TooBig` if the image is too big to process,
     * - `Error::NotQoi` if the the data does not describe a QOI header,
     * - `Error::InvalidDesc` if any of the field of `Desc` contains invalid value,
     * - `Error::NotRegularFile` if file pointed by path is not a regular file,
     * - `Error::FileNotExists` if file pointed by path not exists, or
     * - `Error::IoError` if file can't be opened or read.
     */
    Result<Image> decode(
        const std::filesystem::path& in_path,
        std::optional<Channels>      target          = std::nullopt,
        bool                         flip_vertically = false
    ) noexcept;

    /**
     * @brief Decode the given QOI image.
     *
     * @param out_buf The buffer to be filled with decoded data.
     * @param in_data The QOI image to decode.
     * @param target The target channels to extract; if std::nullopt, the original channels will be used.
     * @param flip_vertically If true, the image will be flip vertically.
     * @return The decoded image or an error.
     *
     * If the underlying data is RGB and the target is RGBA, the alpha channel will be set to 0xFF.
     *
     * The decoder will immediately return `Error::NotEnoughSpace` as soon as the number of bytes calculated
     * from the parsed header is detected to be greater than the size of the `out_buf`, leaving it untouched.
     *
     * This function returns
     * - `Error::Empty` if the length of the data is zero,
     * - `Error::TooShort` if the length of the data passed in less than header length,
     * - `Error::TooBig` if the image is too big to process.
     * - `Error::NotQoi` if the the data does not describe a QOI header,
     * - `Error::InvalidDesc` if any of the field on the header contains invalid value, or
     * - `Error::NotEnoughSpace` if the `out` buffer doesn't have enough space for encoded data.
     */
    Result<Desc> decode_into(
        ByteSpan                out_buf,
        ByteCSpan               in_data,
        std::optional<Channels> target          = std::nullopt,
        bool                    flip_vertically = false
    );

    /**
     * @brief Decode the given QOI image.
     *
     * @param out_func The function that accepts the decoded data (noexcept).
     * @param in_data The QOI image to decode.
     *
     * If the underlying data is RGB and the target is RGBA, the alpha channel will be set to 0xFF.
     *
     * This function returns
     * - `Error::Empty` if the length of the data is zero,
     * - `Error::TooShort` if the length of the data passed in less than header length,
     * - `Error::TooBig` if the image is too big to process.
     * - `Error::NotQoi` if the the data does not describe a QOI header, or
     * - `Error::InvalidDesc` if any of the field on the header contains invalid value.
     */
    Result<Desc> decode_into(PixelSinkFun out_func, ByteCSpan in_data);

    /**
     * @brief Decode a QOI image from a file.
     *
     * @param out_buf The buffer to be filled with decoded data.
     * @param in_path The path to the file.
     * @param target The target channels to extract; if std::nullopt, the original channels will be used.
     * @return Image The decoded image or an error.
     *
     * If the underlying data is RGB and the target is RGBA, the alpha channel will be set to 0xFF.
     *
     * The decoder will immediately return `Error::NotEnoughSpace` as soon as the number of bytes calculated
     * from the parsed header is detected to be greater than the size of the `out_buf`, leaving it untouched.
     *
     * This function returns
     * - `Error::Empty` if the length of the data read from file is zero,
     * - `Error::TooShort` if the length of the data read from file in less than header length,
     * - `Error::TooBig` if the image is too big to process,
     * - `Error::NotQoi` if the the data does not describe a QOI header,
     * - `Error::InvalidDesc` if any of the field of `Desc` contains invalid value,
     * - `Error::NotEnoughSpace` if the `out_buf` buffer doesn't have enough space for encoded data.
     * - `Error::NotRegularFile` if file pointed by path is not a regular file,
     * - `Error::FileNotExists` if file pointed by path not exists, or
     * - `Error::IoError` if file can't be opened or read.
     */
    Result<Desc> decode_into(
        ByteSpan                     out_buf,
        const std::filesystem::path& in_path,
        std::optional<Channels>      target          = std::nullopt,
        bool                         flip_vertically = false
    ) noexcept;

    /**
     * @brief Decode a QOI image from a file.
     *
     * @param out_func The function that accepts the decoded data (noexcept).
     * @param in_path The path to the file.
     * @return Image The decoded image or an error.
     *
     * If the underlying data is RGB and the target is RGBA, the alpha channel will be set to 0xFF.
     *
     * This function returns
     * - `Error::Empty` if the length of the data read from file is zero,
     * - `Error::TooShort` if the length of the data read from file in less than header length,
     * - `Error::TooBig` if the image is too big to process.
     * - `Error::NotQoi` if the the data does not describe a QOI header, or
     * - `Error::InvalidDesc` if any of the field of `Desc` contains invalid value.
     * - `Error::NotRegularFile` if file pointed by path is not a regular file, or
     * - `Error::FileNotExists` if file pointed by path not exists,
     * - `Error::IoError` if file can't be opened or read.
     */
    Result<Desc> decode_into(PixelSinkFun out_func, const std::filesystem::path& in_path) noexcept;
}

#endif
