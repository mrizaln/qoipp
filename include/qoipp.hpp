#ifndef QOIPP_HPP_O4A387W5ER6OW7E
#define QOIPP_HPP_O4A387W5ER6OW7E

#include <cstddef>
#include <filesystem>
#include <functional>
#include <optional>
#include <span>
#include <vector>

namespace qoipp
{
    using Vec  = std::vector<std::uint8_t>;
    using Span = std::span<const std::uint8_t>;

    enum class Colorspace : std::uint8_t
    {
        sRGB   = 0,
        Linear = 1,
    };

    enum class Channels : std::uint8_t
    {
        RGB  = 3,
        RGBA = 4,
    };

    struct PixelRepr
    {
        std::uint8_t r;
        std::uint8_t g;
        std::uint8_t b;
        std::uint8_t a;

        constexpr auto operator<=>(const PixelRepr&) const = default;
    };

    struct ImageDesc
    {
        std::uint32_t width;
        std::uint32_t height;
        Channels      channels;
        Colorspace    colorspace;

        constexpr auto operator<=>(const ImageDesc&) const = default;
    };

    struct Image
    {
        Vec       data;
        ImageDesc desc;
    };

    using PixelGenFun = std::function<PixelRepr(std::size_t pixel_index)>;

    /**
     * @brief Helper function to convert a number of channels to the Channels enum
     *
     * @param channels The number of channels
     * @return std::optional<Channels> The corresponding Channels, or std::nullopt if number is not valid
     */
    template <std::integral T>
    inline constexpr std::optional<Channels> to_channels(T channels) noexcept
    {
        switch (channels) {
        case 3: return Channels::RGB;
        case 4: return Channels::RGBA;
        default: return std::nullopt;
        }
    }

    /**
     * @brief Helper function to convert a number of colorspace to the Colorspace enum
     *
     * @param colorspace The number of colorspace
     * @return std::optional<Colorspace> The corresponding Colorspace, or std::nullopt if number is not valid
     */
    template <std::integral T>
    inline constexpr std::optional<Colorspace> to_colorspace(T colorspace) noexcept
    {
        switch (colorspace) {
        case 0: return Colorspace::sRGB;
        case 1: return Colorspace::Linear;
        default: return std::nullopt;
        }
    }

    /**
     * @brief Read the header of a QOI image
     *
     * @param data The data to read the header from
     * @return std::optional<ImageDesc> The description of the image if it is a valid QOI image
     */
    std::optional<ImageDesc> read_header(Span data) noexcept;

    /**
     * @brief Encode the given data into a QOI image
     *
     * @param data The data to encode
     * @param desc The description of the image
     * @return Vec The encoded image
     * @throw std::invalid_argument If there is a mismatch between the data and the description
     *
     * This function assume that the raw data is in the format of RGB888 or RGBA8888.
     */
    Vec encode(Span data, ImageDesc desc) noexcept(false);

    /**
     * @brief Encode the given data into a QOI image
     *
     * @param data The data to encode
     * @param size The size of the data
     * @param desc The description of the image
     * @return Vec The encoded image
     *
     * This function assume that the raw data is in the format of RGB888 or RGBA8888.
     */
    inline Vec encode(const void* data, std::size_t size, ImageDesc desc) noexcept(false)
    {
        auto byte_data = Span{ reinterpret_cast<const std::uint8_t*>(data), size };
        return encode(byte_data, desc);
    }

    /**
     * @brief Encode the data generated by the given function into a QOI image
     *
     * @param func The function to generate the data
     * @param desc The description of the image
     * @return Vec The encoded image
     *
     * The function should return the pixel at the given location ((0, 0) is at the top-left corner) in the
     * format of RGBA8888 (the alpha channel is discarded if the ImageDesc specifies RGB channels only).
     */
    Vec encode_from_function(PixelGenFun func, ImageDesc desc) noexcept(false);

    /**
     * @brief Decode the given QOI image
     *
     * @param data The QOI image to decode
     * @param target The target channels to extract; if std::nullopt, the original channels will be used
     * @param flip_vertically If true, the image will be flip vertically
     * @return Image The decoded image
     * @throw std::invalid_argument If the data is not a valid QOI image
     *
     * If the underlying data is RGB and the target is RGBA, the alpha channel will be set to 0xFF.
     */
    Image decode(
        Span                    data,
        std::optional<Channels> target          = std::nullopt,
        bool                    flip_vertically = false
    ) noexcept(false);

    /**
     * @brief Decode the given data into a QOI image
     *
     * @param data The data to encode
     * @param size The size of the data
     * @param target The target channels to extract; if std::nullopt, the original channels will be used
     * @param flip_vertically If true, the image will be flip vertically
     * @return Image The decoded image
     * @throw std::invalid_argument If the data is not a valid QOI image
     *
     * If the underlying data is RGB and the target is RGBA, the alpha channel will be set to 0xFF.
     */
    inline Image decode(
        const void*             data,
        std::size_t             size,
        std::optional<Channels> target          = std::nullopt,
        bool                    flip_vertically = false
    ) noexcept(false)
    {
        auto byte_data = Span{ reinterpret_cast<const std::uint8_t*>(data), size };
        return decode(byte_data, target, flip_vertically);
    }

    /**
     * @brief Read the header of a QOI image from a file
     * @param path The path to the file
     * @return std::optional<ImageDesc> The description of the image (std::nullopt if it's invalid)
     */
    std::optional<ImageDesc> read_header_from_file(const std::filesystem::path& path) noexcept;

    /**
     * @brief Encode the given data into a QOI image and write it to a file
     * @param path The path to the file
     * @param data The data to encode
     * @param desc The description of the image
     * @param overwrite If true, the file will be overwritten if it already exists
     * @throw std::invalid_argument If the file already exists and overwrite is false or if there is a
     * mismatch between the data and the description
     */
    void encode_to_file(
        const std::filesystem::path& path,
        Span                         data,
        ImageDesc                    desc,
        bool                         overwrite = false
    ) noexcept(false);

    /**
     * @brief Decode a QOI image from a file
     *
     * @param path The path to the file
     * @param target The target channels to extract; if std::nullopt, the original channels will be used
     * @return Image The decoded image
     * @throw std::invalid_argument If the file is not exist or not a valid QOI image
     *
     * If the underlying data is RGB and the target is RGBA, the alpha channel will be set to 0xFF.
     */
    Image decode_from_file(
        const std::filesystem::path& path,
        std::optional<Channels>      target          = std::nullopt,
        bool                         flip_vertically = false
    ) noexcept(false);
}

#endif /* end of include guard: QOIPP_HPP_O4A387W5ER6OW7E */
